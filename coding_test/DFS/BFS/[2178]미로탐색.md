백준 2178번 미로탐색 문제이다.
BFS / DFS 의 basic한 문제이다. 가장 기본적인 문제이므로 이 형식을 외워서 나머지 문제에 적용하는 것도
괜찮아 보인다.


```c++
#include <iostream>
#include <queue>
using namespace std;

int n, m;
int dy[4] = { -1,0,1,0 };
int dx[4] = { 0,1,0,-1 };

int maze[104][104];
int visited[104][104];
int ret = 999;

void dfs(int y, int x, int cnt) {
	
    // 만약 벽밖에 나갔거나, 이미 방문한 지점, 방문할 수 없는 지점이라면 통과
	if (y<0 || y>=n || x<0 || x>=m || maze[y][x]==0 || visited[y][x]) return;
	if (y == n - 1 && x == m - 1) { // 만약 좌표가 목표지점이라면
		if (ret > cnt) ret = cnt;   // 최단 경로라면 그 값을 저장한다.
		return;
	}

    // dfs의 무한 탐색을 막기위해서는 visited 배열을 활용해야 한다.
	visited[y][x] = 1;
	for (int i = 0; i < 4; i++) { // for문으로 네가지 방향을 모두 탐색한다.
		int ny = y + dy[i];
		int nx = x + dx[i];
		dfs(ny, nx, cnt+1);
	}
    // 한 경로에 대해서 visited 배열을 초기화 해주어야, 나머지 경로를 다시 찾을 수 있다.
	visited[y][x] = 0;
}

void bfs() {
	queue<pair<int, int>> q;
	q.push({ 0,0 });
	visited[0][0] = 1;

	while (q.size()) {
		int y = q.front().first;
		int x = q.front().second;
		q.pop();

		for (int i = 0; i < 4; i++) {
			int ny = y + dy[i];
			int nx = x + dx[i];
			if (ny < 0 || ny >= n || nx < 0 || nx >= m || maze[ny][nx] == 0) continue;
            // 내가 실수한 부분, 방문여부를 체크해 주어야한다.
			if (visited[ny][nx]) continue;
			visited[ny][nx] = visited[y][x] + 1;
			q.push({ ny,nx });
		}
	}
}


int main() {
	cin >> n >> m;

	string s;
	for (int i = 0; i < n; i++) {
		cin >> s;
		for (int j = 0; j < m; j++) {
			maze[i][j] = s[j] - '0';
		}
	}

	//dfs(0, 0,1);
	//cout << ret;

	bfs();
	cout << visited[n - 1][m - 1];
}
```

[문제접근]
처음에 문제를 풀때 dfs방식으로 문제를 풀면 시간초과가 발생했다. DFS의 특성상 한 경로를 끝까지 탐색한 뒤, 돌아와서 다른 경로를 모두 탐색하므로, 최단경로를 찾더라고 모든 가능한 경로를 다 확인해야 하므로, 경우의 수가 많아질수록 탐색시간이 기하급수적으로 늘어나게 된다.

이를 해결하기 위해서, bfs방식을 택하여 시간복잡도를 줄일 수 있었다.

1. 최단 경로 보장
BFS는 시작점에서부터 모든 경로를 동시에 한 칸씩 넓혀가며 탐색합니다.
따라서 도착점에 처음 도달하는 순간이 곧 최단 경로입니다.

2. 불필요한 경로 탐색 방지
BFS는 이미 방문한 칸을 다시 방문하지 않으므로, 중복 경로 탐색이 없습니다.
DFS는 모든 경로를 끝까지 탐색해야 하므로, 경우의 수가 많아질수록 시간이 오래 걸립니다.

3. 시간복잡도 효율
BFS는 각 칸을 한 번씩만 방문하므로, **O(NM)**의 시간복잡도로 빠르게 동작합니다.
DFS는 최악의 경우 모든 경로를 다 탐색해야 하므로, 경우의 수가 많아지면 시간초과가 발생할 수 있습니다.

