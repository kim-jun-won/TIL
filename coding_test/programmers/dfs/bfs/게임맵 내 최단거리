# 🧭 게임 맵 최단 거리 문제 정리 (BFS 기반)

## 🔍 문제 요약

게임 맵이 주어진다.  
- `maps[i][j] = 1`: 지나갈 수 있는 길  
- `maps[i][j] = 0`: 벽  
시작점 `(0, 0)`에서 도착점 `(n-1, m-1)`까지 **최단 거리로 도달**하는 경로의 칸 수를 구하라.  
단, 도달할 수 없다면 `-1`을 반환한다.

---

## 🎯 핵심 아이디어

- 이 문제는 **최단 거리**를 묻고 있으므로, 무조건 `BFS`로 접근해야 함.
- `DFS`는 깊게 들어가기 때문에 최단 거리를 보장하지 않음.
- BFS는 **레벨 순서대로 탐색**하기 때문에 도착 지점에 처음 도달했을 때의 거리가 항상 최단 거리.

### BFS 기본 구조

- 시작점에서부터 큐에 넣고 탐색
- 상, 하, 좌, 우 방향으로 한 칸씩 이동
- `visited` 배열로 중복 탐색 방지
- `distance[y][x] = distance[prev] + 1` 로 거리 누적

---

## ⚠️ 실수했던 포인트

### 🔸 `distance` 초기화 순서 실수

```cpp my code

#include<vector>
#include<queue>
using namespace std;

queue<pair<int, int>> q;

int dy[4] = { -1,0,1,0 };
int dx[4] = { 0,-1,0,1 };
int d[104][104];
bool visited[104][104];

// 1. 어떻게 거리를 저장할 변수를 저장할 것인지?

void bfs(int y, int x, vector<vector<int>> &maps) {
    int n = maps.size();
    int m = maps[0].size();
    // start point
    d[y][x] = 1;

    q.push({ y,x });
    while (!q.empty()) {
        int y = q.front().first;
        int x = q.front().second;
        q.pop();
        
        for (int i = 0; i < 4; i++) {
            int ny = y + dy[i];
            int nx = x + dx[i];
            if (ny < 0 || nx < 0 || ny >= n || nx >= m) continue;
            if (visited[ny][nx] || maps[ny][nx]==0) continue;

            visited[ny][nx] = true;

            d[ny][nx] = d[y][x] + 1;
            q.push({ ny,nx });
        }
    }
}

int solution(vector<vector<int>> maps)
{

    // 거리 초기화
    for (int i = 0; i < 104; i++)
        for (int j = 0; j < 104; j++)
            d[i][j] = -1;

    bfs(0, 0, maps);


    int n = maps.size();
    int m = maps[0].size();

    if (d[n - 1][m - 1] == -1) return -1;
    else return d[n-1][m-1];
   
}
```

